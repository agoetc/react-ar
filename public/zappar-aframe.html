<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Zappar + A-Frame Sample</title>
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- Zappar A-Frame (CDN). If the version changes, update this URL. -->
    <script src="https://libs.zappar.com/zappar-aframe/2.0.0/zappar-aframe.js"></script>
    <style>
      html, body { margin: 0; height: 100%; background: #000; }
      .overlay { position: fixed; top: 0; left: 0; right: 0; padding: 12px 14px; color: #fff; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; background: linear-gradient(rgba(0,0,0,.55), rgba(0,0,0,0)); z-index: 10; }
      .hint { position: fixed; bottom: 0; left: 0; right: 0; padding: 12px 14px; color: #fff; text-align: center; background: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,.55)); z-index: 10; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; }
      a { color: #9ad; }
    </style>
  </head>
  <body>
    <div class="overlay" id="hud">Zappar + A‑Frame: ワールド上に画像を配置（タップで配置/固定）</div>
    <div class="hint">画面をタップして画像を配置・固定できます</div>

    <!-- AR Scene -->
    <a-scene
      vr-mode-ui="enabled: false"
      renderer="colorManagement: true; physicallyCorrectLights: true; logarithmicDepthBuffer: true"
      embedded
    >
      <!-- Permissions & Compatibility UIs -->
      <a-entity zappar-permissions-ui></a-entity>
      <a-entity zappar-compatibility-ui></a-entity>

      <!-- Camera -->
      <a-camera zappar-camera="userFacing: false"></a-camera>

      <!-- Assets -->
      <a-assets id="assets"></a-assets>

      <!-- Instant World Tracking Anchor -->
      <a-entity id="instantAnchor" zappar-instant="placement-mode: true"></a-entity>
    </a-scene>

    <script>
      const anchor = document.getElementById('instantAnchor');
      const assets = document.getElementById('assets');
      const hud = document.getElementById('hud');
      // Cache map: image URL -> asset selector (e.g., #img_0)
      const imageAssetCache = new Map();
      let imageAssetSeq = 0;
      let deviceHeadingDeg = 0; // 0..360, 0 = 北（仮定）
      let headingStarted = false;

      // Toggle placement mode on tap (place/fix content)
      const togglePlacement = () => {
        const current = anchor.getAttribute('zappar-instant');
        const placing = current && (current.placementMode === true || current.placementMode === 'true');
        anchor.setAttribute('zappar-instant', 'placement-mode', placing ? 'false' : 'true');
        // On first user gesture, try to start device orientation permissions
        ensureHeadingPermission();
      };
      document.body.addEventListener('click', togglePlacement);

      function handleOrientation(e) {
        let heading = null;
        // iOS Safari provides webkitCompassHeading (0 = 北, 時計回り)
        if (typeof e.webkitCompassHeading === 'number') {
          heading = e.webkitCompassHeading;
        } else if (e.absolute === true && typeof e.alpha === 'number') {
          // 一部ブラウザでは alpha が真北基準（0=北）の場合があるため簡易対応
          heading = 360 - e.alpha; // 右回りに正となるよう反転
        }
        if (heading != null && isFinite(heading)) {
          deviceHeadingDeg = (heading + 360) % 360;
          // console.log('[Heading] 現在の方位(度):', deviceHeadingDeg.toFixed(1));
        }
      }

      function handleOrientationAbsolute(e) {
        // Some browsers fire a separate absolute event
        handleOrientation(e);
      }

      function startHeading() {
        if (headingStarted) return;
        headingStarted = true;
        window.addEventListener('deviceorientation', handleOrientation, true);
        window.addEventListener('deviceorientationabsolute', handleOrientationAbsolute, true);
      }

      function ensureHeadingPermission() {
        if (headingStarted) return;
        try {
          const maybe = window.DeviceOrientationEvent;
          if (maybe && typeof maybe.requestPermission === 'function') {
            maybe.requestPermission().then((res) => {
              if (res === 'granted') startHeading();
            }).catch((err) => console.warn('DeviceOrientation permission error', err));
          } else {
            startHeading();
          }
        } catch (e) {
          console.warn('DeviceOrientation init error', e);
        }
      }

      // Haversine distance in kilometers
      function haversine(lat1, lon1, lat2, lon2) {
        const toRad = (d) => (d * Math.PI) / 180;
        const R = 6371; // km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      async function fetchImageObjects() {
        const res = await fetch('/api/image-objects', { cache: 'no-store' });
        if (!res.ok) throw new Error('failed to fetch image objects');
        return await res.json();
      }

      function selectNearby(data, userLat, userLon) {
        const withDist = data.map((d) => ({
          ...d,
          distanceKm: haversine(userLat, userLon, d.latitude, d.longitude),
        }));
        withDist.sort((a, b) => a.distanceKm - b.distanceKm);
        const within = withDist.filter((d) => d.distanceKm <= 100); // within 100km
        return (within.length ? within : withDist).slice(0, 5); // show up to 5
      }

      // Initial bearing (degrees) from (lat1, lon1) to (lat2, lon2)
      function bearingDeg(lat1, lon1, lat2, lon2) {
        const toRad = (d) => (d * Math.PI) / 180;
        const toDeg = (r) => (r * 180) / Math.PI;
        const φ1 = toRad(lat1);
        const φ2 = toRad(lat2);
        const Δλ = toRad(lon2 - lon1);
        const y = Math.sin(Δλ) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
        let θ = toDeg(Math.atan2(y, x));
        return (θ + 360) % 360; // normalize 0..360
      }

      function kmToMetersScaled(km) {
        // Tunable mapping: 1km -> 0.08m, clamped to [0.6m, 8m]
        const SCALE = 0.08;
        return Math.max(0.6, Math.min(8, km * SCALE));
      }

      function addPlanes(items, user) {
        // Clear existing
        while (anchor.firstChild) anchor.removeChild(anchor.firstChild);

        items.forEach((item, idx) => {
          // Ensure cached <img> asset exists and get its selector
          const assetSelector = ensureAssetFor(item.imagePath);
          // Compute radial placement from user to item using geographic bearing
          const bearing = bearingDeg(user.latitude, user.longitude, item.latitude, item.longitude);
          const distanceKm = haversine(user.latitude, user.longitude, item.latitude, item.longitude);
          const r = kmToMetersScaled(distanceKm);
          const rad = (bearing * Math.PI) / 180;

          // A-Frame: -Z forward, X right. Map 0° (north) -> forward (-Z)
          const x = Math.sin(rad) * r;
          const z = -Math.cos(rad) * r;

          // Height from data (meters), clamped
          const y = Math.max(0, Math.min(5, Number(item.height) || 0));

          const plane = document.createElement('a-plane');
          // Use cached asset by id (e.g., #img_0) so the same HTMLImageElement/texture is reused
          plane.setAttribute('src', assetSelector);
          plane.setAttribute('position', `${x.toFixed(3)} ${y.toFixed(3)} ${z.toFixed(3)}`);

          // Rotate around Y by the object's direction minus user's heading.
          // A-Frame plane faces +Z by default; camera faces -Z. Add 180° offset so 0° faces -Z (north).
          const yawBase = (((Number(item.direction) || 0) - deviceHeadingDeg) + 360) % 360;
          const yaw = (yawBase + 180) % 360;
          plane.setAttribute('rotation', `0 ${yaw.toFixed(1)} 0`);

          // Size (meters) and render sides
          plane.setAttribute('width', '1.0');
          plane.setAttribute('height', '1.0');
          plane.setAttribute('material', 'side: double; transparent: true;');

          anchor.appendChild(plane);
        });
      }

      function ensureAssetFor(url) {
        if (imageAssetCache.has(url)) return imageAssetCache.get(url);
        const id = `img_${imageAssetSeq++}`;
        const img = document.createElement('img');
        img.setAttribute('id', id);
        img.setAttribute('src', url);
        img.setAttribute('crossorigin', 'anonymous');
        assets.appendChild(img);
        const selector = `#${id}`;
        imageAssetCache.set(url, selector);
        return selector;
      }

      // Cache for image objects and last known position
      let cachedImageObjects = null;
      let lastPosition = null;

      function renderWithPosition(lat, lon) {
        if (!cachedImageObjects) return; // not ready yet
        const items = selectNearby(cachedImageObjects, lat, lon);
        console.log('[AR] rendering', items.length, 'items at', { lat, lon, heading: deviceHeadingDeg.toFixed(1) });
        addPlanes(items, { latitude: lat, longitude: lon });
        if (hud) {
          hud.textContent = `Zappar + A‑Frame | lat: ${lat.toFixed(6)} lon: ${lon.toFixed(6)} | heading: ${deviceHeadingDeg.toFixed(1)}°`;
        }
      }

      function startGeolocationLoop() {
        // Re-render every 100ms using the latest known position
        setInterval(() => {
          if (lastPosition) {
            const { latitude, longitude } = lastPosition.coords;
            renderWithPosition(latitude, longitude);
          }
        }, 100);

        if (!navigator.geolocation) {
          onGeoError(new Error('Geolocation not supported'));
          return;
        }

        // Continuously update lastPosition
        navigator.geolocation.watchPosition(
          (pos) => {
            lastPosition = pos;
            const { latitude, longitude } = pos.coords;
            console.log('[Geolocation] 現在の緯度経度:', { latitude, longitude });
          },
          onGeoError,
          { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
        );
      }

      function onGeoError(err) {
        console.warn('Geolocation error', err);
        // Fallback: use Tokyo Station and still keep the 500ms loop
        const latitude = 35.681236, longitude = 139.767125;
        console.log('[Geolocation] 取得失敗のため東京駅座標を使用:', { latitude, longitude });
        lastPosition = { coords: { latitude, longitude } };
      }

      // Boot: fetch data once, then start geolocation + render loop
      fetchImageObjects()
        .then((data) => {
          cachedImageObjects = data;
          // Pre-warm assets for all unique image paths
          try {
            const unique = Array.from(new Set((data || []).map((d) => d.imagePath)));
            unique.forEach((u) => ensureAssetFor(u));
          } catch (e) { /* noop */ }
          startGeolocationLoop();
        })
        .catch((e) => {
          console.error('Failed to load image objects', e);
          startGeolocationLoop();
        });
    </script>
  </body>
  </html>
