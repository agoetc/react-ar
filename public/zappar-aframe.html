<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Zappar + A-Frame Sample</title>
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- Zappar A-Frame (CDN). If the version changes, update this URL. -->
    <script src="https://libs.zappar.com/zappar-aframe/2.0.0/zappar-aframe.js"></script>
    <style>
      html, body { margin: 0; height: 100%; background: #000; }
      .overlay { position: fixed; top: 0; left: 0; right: 0; padding: 12px 14px; color: #fff; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; background: linear-gradient(rgba(0,0,0,.55), rgba(0,0,0,0)); z-index: 10; }
      .hint { position: fixed; bottom: 0; left: 0; right: 0; padding: 12px 14px; color: #fff; text-align: center; background: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,.55)); z-index: 10; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; }
      a { color: #9ad; }
    </style>
  </head>
  <body>
    <div class="overlay">Zappar + A‑Frame: ワールド上に画像を配置（タップで配置/固定）</div>
    <div class="hint">画面をタップして画像を配置・固定できます</div>

    <!-- AR Scene -->
    <a-scene
      vr-mode-ui="enabled: false"
      renderer="colorManagement: true; physicallyCorrectLights: true; logarithmicDepthBuffer: true"
      embedded
    >
      <!-- Permissions & Compatibility UIs -->
      <a-entity zappar-permissions-ui></a-entity>
      <a-entity zappar-compatibility-ui></a-entity>

      <!-- Camera -->
      <a-camera zappar-camera="userFacing: false"></a-camera>

      <!-- Assets -->
      <a-assets id="assets"></a-assets>

      <!-- Instant World Tracking Anchor -->
      <a-entity id="instantAnchor" zappar-instant="placement-mode: true"></a-entity>
    </a-scene>

    <script>
      const anchor = document.getElementById('instantAnchor');
      const assets = document.getElementById('assets');

      // Toggle placement mode on tap (place/fix content)
      const togglePlacement = () => {
        const current = anchor.getAttribute('zappar-instant');
        const placing = current && (current.placementMode === true || current.placementMode === 'true');
        anchor.setAttribute('zappar-instant', 'placement-mode', placing ? 'false' : 'true');
      };
      document.body.addEventListener('click', togglePlacement);

      // Haversine distance in kilometers
      function haversine(lat1, lon1, lat2, lon2) {
        const toRad = (d) => (d * Math.PI) / 180;
        const R = 6371; // km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      async function fetchImageObjects() {
        const res = await fetch('/api/image-objects', { cache: 'no-store' });
        if (!res.ok) throw new Error('failed to fetch image objects');
        return await res.json();
      }

      function selectNearby(data, userLat, userLon) {
        const withDist = data.map((d) => ({
          ...d,
          distanceKm: haversine(userLat, userLon, d.latitude, d.longitude),
        }));
        withDist.sort((a, b) => a.distanceKm - b.distanceKm);
        const within = withDist.filter((d) => d.distanceKm <= 100); // within 100km
        return (within.length ? within : withDist).slice(0, 5); // show up to 5
      }

      function addPlanes(items) {
        // Clear existing
        while (anchor.firstChild) anchor.removeChild(anchor.firstChild);

        // Arrange planes in a circle around the origin
        const radius = 0.8; // meters
        const y = 0; // height on ground plane

        items.forEach((item, idx) => {
          // Add asset image
          const img = document.createElement('img');
          const assetId = `img_${idx}`;
          img.setAttribute('id', assetId);
          img.setAttribute('src', item.imagePath);
          img.setAttribute('crossorigin', 'anonymous');
          assets.appendChild(img);

          const angle = (idx / items.length) * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;

          const plane = document.createElement('a-plane');
          plane.setAttribute('src', `#${assetId}`);
          plane.setAttribute('position', `${x} ${y} ${z}`);
          plane.setAttribute('rotation', `-90 0 0`);
          plane.setAttribute('width', '0.6');
          plane.setAttribute('height', '0.6');

          anchor.appendChild(plane);
        });
      }

      function onGeolocated(pos) {
        const { latitude, longitude } = pos.coords;
        console.log('[Geolocation] 現在の緯度経度:', { latitude, longitude });
        fetchImageObjects()
          .then((data) => selectNearby(data, latitude, longitude))
          .then(addPlanes)
          .catch((e) => {
            console.error(e);
          });
      }

      function onGeoError(err) {
        console.warn('Geolocation error', err);
        // Fallback: load nearest from a default location (Tokyo)
        const latitude = 35.681236, longitude = 139.767125;
        console.log('[Geolocation] 取得失敗のため東京駅座標を使用:', { latitude, longitude });
        fetchImageObjects()
          .then((data) => selectNearby(data, latitude, longitude))
          .then(addPlanes)
          .catch((e) => console.error(e));
      }

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(onGeolocated, onGeoError, {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0,
        });
      } else {
        onGeoError(new Error('Geolocation not supported'));
      }
    </script>
  </body>
  </html>
