<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Zappar + A-Frame Sample</title>
    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- Zappar A-Frame (CDN). If the version changes, update this URL. -->
    <script src="https://libs.zappar.com/zappar-aframe/2.0.0/zappar-aframe.js"></script>
    <style>
      html, body { margin: 0; height: 100%; background: #000; }
      .overlay { position: fixed; top: 0; left: 0; right: 0; padding: 12px 14px; color: #fff; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; background: linear-gradient(rgba(0,0,0,.55), rgba(0,0,0,0)); z-index: 10; }
      .image-list { position: fixed; bottom: 20px; right: 20px; width: 280px; max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.8); border-radius: 8px; padding: 12px; color: #fff; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif; font-size: 12px; z-index: 20; }
      .image-item { display: flex; align-items: center; margin-bottom: 8px; padding: 6px; background: rgba(255,255,255,0.1); border-radius: 4px; }
      .image-item img { width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 8px; }
      .image-info { flex: 1; }
      .image-name { font-weight: 600; margin-bottom: 2px; }
      .image-details { color: #ccc; font-size: 11px; }
      a { color: #9ad; }
    </style>
  </head>
  <body>
    <div class="overlay" id="hud">AR絵画ビューアー</div>
    <div class="image-list" id="imageList">
      <div style="font-weight: 600; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 4px;">読み込み中の画像</div>
    </div>

    <!-- AR Scene -->
    <a-scene
      vr-mode-ui="enabled: false"
      renderer="colorManagement: true; physicallyCorrectLights: true; logarithmicDepthBuffer: true"
      embedded
    >
      <!-- Permissions & Compatibility UIs -->
      <a-entity zappar-permissions-ui></a-entity>
      <a-entity zappar-compatibility-ui></a-entity>

      <!-- Camera -->
      <a-camera zappar-camera="userFacing: false"></a-camera>

      <!-- Assets -->
      <a-assets id="assets"></a-assets>

      <!-- Instant World Tracking Anchor -->
      <a-entity id="worldGroup" zappar-instant="placement-mode: true">
        <!-- Test plane: red square 2m in front -->
        <a-plane position="0 1.5 -2" width="1" height="1" material="color: red; side: double;" visible="true"></a-plane>
        <!-- Test plane: blue square 1m to the right -->
        <a-plane position="1 1.5 -1.5" width="1" height="1" material="color: blue; side: double;" visible="true"></a-plane>
        <!-- Test plane: green square close to camera -->
        <a-plane position="0 1.6 -0.5" width="0.3" height="0.3" material="color: green; side: double;" visible="true"></a-plane>
        <!-- Test box for depth reference -->
        <a-box position="0 0 -3" width="0.5" height="0.5" depth="0.5" material="color: yellow" visible="true"></a-box>
      </a-entity>
    </a-scene>

    <script>
      const anchor = document.getElementById('worldGroup');
      const assets = document.getElementById('assets');
      const hud = document.getElementById('hud');
      const imageList = document.getElementById('imageList');
      // Cache map: image URL -> asset selector (e.g., #img_0)
      const imageAssetCache = new Map();
      let imageAssetSeq = 0;
      // Plane cache: stable key (imagePath + lat/long) -> a-plane element
      const planeCache = new Map();
      let deviceHeadingDeg = 0; // 0..360, 0 = 北（仮定）
      let headingStarted = false;
      // Auto-place and fix anchor after first interaction
      let anchorPlaced = false;
      let orientationStarted = false;
      
      const placeAnchorOnce = () => {
        if (!anchorPlaced) {
          anchorPlaced = true;
          console.log('[AR] Placing instant tracking anchor');
          
          // Auto-place after 1 second
          setTimeout(() => {
            anchor.setAttribute('zappar-instant', 'placement-mode', 'false');
            console.log('[AR] Anchor placed and fixed');
          }, 1000);
        }
      };
      
      const startOrientationOnce = () => {
        if (!orientationStarted) {
          orientationStarted = true;
          ensureHeadingPermission();
          placeAnchorOnce();
        }
      };
      document.body.addEventListener('click', startOrientationOnce, { once: true });

      function handleOrientation(e) {
        let heading = null;
        // iOS Safari provides webkitCompassHeading (0 = 北, 時計回り)
        if (typeof e.webkitCompassHeading === 'number') {
          heading = e.webkitCompassHeading;
        } else if (typeof e.alpha === 'number') {
          // Android/other browsers: alpha is compass heading
          heading = e.alpha;
        }
        if (heading != null && isFinite(heading)) {
          deviceHeadingDeg = (heading + 360) % 360;
        }
      }

      function handleOrientationAbsolute(e) {
        // Some browsers fire a separate absolute event
        handleOrientation(e);
      }

      function startHeading() {
        if (headingStarted) return;
        headingStarted = true;
        window.addEventListener('deviceorientation', handleOrientation, true);
        window.addEventListener('deviceorientationabsolute', handleOrientationAbsolute, true);
      }

      function ensureHeadingPermission() {
        if (headingStarted) return;
        try {
          const maybe = window.DeviceOrientationEvent;
          if (maybe && typeof maybe.requestPermission === 'function') {
            maybe.requestPermission().then((res) => {
              if (res === 'granted') startHeading();
            }).catch((err) => console.warn('DeviceOrientation permission error', err));
          } else {
            startHeading();
          }
        } catch (e) {
          console.warn('DeviceOrientation init error', e);
        }
      }

      // Haversine distance in kilometers
      function haversine(lat1, lon1, lat2, lon2) {
        const toRad = (d) => (d * Math.PI) / 180;
        const R = 6371; // km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      async function fetchImageObjects() {
        const res = await fetch('/api/image-objects', { cache: 'no-store' });
        if (!res.ok) throw new Error('failed to fetch image objects');
        return await res.json();
      }

      function selectNearby(data, userLat, userLon) {
        const withDist = data.map((d) => ({
          ...d,
          distanceKm: haversine(userLat, userLon, d.latitude, d.longitude),
        }));
        withDist.sort((a, b) => a.distanceKm - b.distanceKm);
        const within = withDist.filter((d) => d.distanceKm <= 100); // within 100km
        return (within.length ? within : withDist).slice(0, 5); // show up to 5
      }

      // Initial bearing (degrees) from (lat1, lon1) to (lat2, lon2)
      function bearingDeg(lat1, lon1, lat2, lon2) {
        const toRad = (d) => (d * Math.PI) / 180;
        const toDeg = (r) => (r * 180) / Math.PI;
        const φ1 = toRad(lat1);
        const φ2 = toRad(lat2);
        const Δλ = toRad(lon2 - lon1);
        const y = Math.sin(Δλ) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
        let θ = toDeg(Math.atan2(y, x));
        return (θ + 360) % 360; // normalize 0..360
      }

      function kmToMetersScaled(km) {
        // Tunable mapping: 1km -> 0.08m, clamped to [0.6m, 8m]
        const SCALE = 0.08;
        return Math.max(0.6, Math.min(8, km * SCALE));
      }

      function updateImageList(items, user) {
        const header = imageList.querySelector('div');
        header.textContent = `読み込み済み画像 (${items.length})`;
        
        // Remove existing items except header
        const existingItems = imageList.querySelectorAll('.image-item');
        existingItems.forEach(item => item.remove());
        
        items.forEach((item, idx) => {
          const bearing = bearingDeg(user.latitude, user.longitude, item.latitude, item.longitude);
          const distanceKm = haversine(user.latitude, user.longitude, item.latitude, item.longitude);
          
          const itemDiv = document.createElement('div');
          itemDiv.className = 'image-item';
          
          const img = document.createElement('img');
          img.src = item.imagePath;
          img.onerror = () => { img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40"><rect width="40" height="40" fill="%23333"/><text x="20" y="25" text-anchor="middle" fill="white" font-size="10">IMG</text></svg>'; };
          
          const infoDiv = document.createElement('div');
          infoDiv.className = 'image-info';
          
          const name = document.createElement('div');
          name.className = 'image-name';
          name.textContent = item.name || `画像 ${idx + 1}`;
          
          const details = document.createElement('div');
          details.className = 'image-details';
          details.textContent = `${distanceKm.toFixed(1)}km | ${bearing.toFixed(0)}°`;
          
          infoDiv.appendChild(name);
          infoDiv.appendChild(details);
          itemDiv.appendChild(img);
          itemDiv.appendChild(infoDiv);
          imageList.appendChild(itemDiv);
        });
      }

      function updatePlanes(items, user) {
        const activeKeys = new Set();

        items.forEach((item, idx) => {
          const key = `${item.imagePath}|${item.latitude},${item.longitude}`;
          activeKeys.add(key);
          // Ensure cached <img> asset exists and get its selector
          const assetSelector = ensureAssetFor(item.imagePath);
          // Compute radial placement from user to item using geographic bearing
          const bearing = bearingDeg(user.latitude, user.longitude, item.latitude, item.longitude);
          const distanceKm = haversine(user.latitude, user.longitude, item.latitude, item.longitude);
          const r = kmToMetersScaled(distanceKm);
          const rad = (bearing * Math.PI) / 180;

          // A-Frame: -Z forward, X right. Map 0° (north) -> forward (-Z)
          let x = Math.sin(rad) * r;
          let z = -Math.cos(rad) * r;

          // For testing: place first image closer for visibility
          if (idx === 0) {
            console.log('[DEBUG] Adjusting first image position for testing');
            const scale = Math.min(1.0, r / 3); // Scale down if too far
            x = x * scale;
            z = z * scale;
            // Ensure minimum distance of 1.5m
            const currentDist = Math.sqrt(x*x + z*z);
            if (currentDist < 1.5) {
              x = (x / currentDist) * 1.5;
              z = (z / currentDist) * 1.5;
            }
          }

          // Height from data (meters), clamped, default to eye level if 0
          const y = Math.max(1.5, Math.min(5, Number(item.height) || 1.5));

          let plane = planeCache.get(key);
          if (!plane) {
            plane = document.createElement('a-plane');
            // Static attributes: src, size, material
            plane.setAttribute('src', assetSelector);
            plane.setAttribute('width', '1.0');
            plane.setAttribute('height', '1.0');
            plane.setAttribute('material', 'side: double; transparent: true;');
            
            // Debug: add colored border and test visibility
            console.log(`[PLANE] Creating plane at ${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)}`);
            
            anchor.appendChild(plane);
            planeCache.set(key, plane);
            
            // Debug: ensure the plane is actually added
            console.log(`[PLANE] Plane added to anchor, total children: ${anchor.children.length}`);
          } else {
            // Ensure visible if reused
            plane.setAttribute('visible', 'true');
            console.log(`[PLANE] Reusing existing plane`);
          }
          // Debug logging
          console.log(`[DEBUG] Item ${idx}:`, {
            bearing: bearing.toFixed(1),
            distanceKm: distanceKm.toFixed(3),
            r: r.toFixed(3),
            x: x.toFixed(3),
            y: y.toFixed(3),
            z: z.toFixed(3),
            deviceHeading: deviceHeadingDeg.toFixed(1)
          });

          // Dynamic attributes each frame
          plane.setAttribute('position', `${x.toFixed(3)} ${y.toFixed(3)} ${z.toFixed(3)}`);

          // Rotate around Y by the object's direction minus user's heading.
          // A-Frame plane faces +Z by default; camera faces -Z. Add 180° offset so 0° faces -Z (north).
          const yawBase = (((Number(item.direction) || 0) - deviceHeadingDeg) + 360) % 360;
          const yaw = (yawBase + 180) % 360;
          plane.setAttribute('rotation', `0 ${yaw.toFixed(1)} 0`);

        });

        // Hide planes not active this frame to avoid re-creation churn
        planeCache.forEach((plane, key) => {
          if (!activeKeys.has(key)) {
            plane.setAttribute('visible', 'false');
          }
        });
      }

      function ensureAssetFor(url) {
        if (imageAssetCache.has(url)) return imageAssetCache.get(url);
        const id = `img_${imageAssetSeq++}`;
        const img = document.createElement('img');
        img.setAttribute('id', id);
        img.setAttribute('src', url);
        img.setAttribute('crossorigin', 'anonymous');
        
        // Debug image loading
        img.onload = () => console.log(`[IMG] Loaded: ${url}`);
        img.onerror = (e) => console.error(`[IMG] Failed to load: ${url}`, e);
        
        assets.appendChild(img);
        const selector = `#${id}`;
        imageAssetCache.set(url, selector);
        console.log(`[ASSET] Created asset ${selector} for ${url}`);
        return selector;
      }

      // Cache for image objects and last known position
      let cachedImageObjects = null;
      let lastPosition = null;

      function renderWithPosition(lat, lon) {
        if (!cachedImageObjects) return; // not ready yet
        const items = selectNearby(cachedImageObjects, lat, lon);
        console.log('[AR] rendering', items.length, 'items at', { lat, lon, heading: deviceHeadingDeg.toFixed(1) });
        const user = { latitude: lat, longitude: lon };
        updatePlanes(items, user);
        updateImageList(items, user);
        if (hud) {
          hud.textContent = `Zappar + A‑Frame | lat: ${lat.toFixed(6)} lon: ${lon.toFixed(6)} | heading: ${deviceHeadingDeg.toFixed(1)}°`;
        }

      }

      function startGeolocationLoop() {
        // Re-render every 100ms using the latest known position
        setInterval(() => {
          if (lastPosition) {
            const { latitude, longitude } = lastPosition.coords;
            renderWithPosition(latitude, longitude);
          }
        }, 50);

        if (!navigator.geolocation) {
          onGeoError(new Error('Geolocation not supported'));
          return;
        }

        // Continuously update lastPosition
        navigator.geolocation.watchPosition(
          (pos) => {
            lastPosition = pos;
            const { latitude, longitude } = pos.coords;
            console.log('[Geolocation] 現在の緯度経度:', { latitude, longitude });
          },
          onGeoError,
          { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
        );
      }

      function onGeoError(err) {
        console.warn('Geolocation error', err);
        // Fallback: use user location and still keep the 500ms loop
        const latitude = 34.469591, longitude = 135.436995;
        console.log('[Geolocation] 取得失敗のためユーザー座標を使用:', { latitude, longitude });
        lastPosition = { coords: { latitude, longitude } };
      }

      // Boot: fetch data once, then start geolocation + render loop
      fetchImageObjects()
        .then((data) => {
          cachedImageObjects = data;
          // Pre-warm assets for all unique image paths
          try {
            const unique = Array.from(new Set((data || []).map((d) => d.imagePath)));
            unique.forEach((u) => ensureAssetFor(u));
          } catch (e) { /* noop */ }
          startGeolocationLoop();
        })
        .catch((e) => {
          console.error('Failed to load image objects', e);
          startGeolocationLoop();
        });
    </script>
  </body>
  </html>
